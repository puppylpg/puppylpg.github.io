---
layout: post
title: Refresh - 回溯
date: 2024-05-04 23:59:38 +0800
render_with_liquid: false
---

关于普通回溯、树的dfs（和bfs）、图的dfs。

1. Table of Contents, ordered
{:toc}

# 回溯DFS
回溯其实就是dfs。

比如[括号生成](https://leetcode.cn/problems/generate-parentheses/solution/gua-hao-sheng-cheng-by-leetcode-solution/)和[电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solution/dian-hua-hao-ma-de-zi-mu-zu-he-by-leetcode-solutio/)，其思路就是：
1. 当前情况和接下来的a去组合；
2. 退回来，当前情况和接下来的b去组合；
3. 退回来，……
4. 每一种情况的结束条件：字符够长了，到底了；

仔细想想，**他们的本质就是在构建N叉树**。因此对每种情况是否还要继续递归进去所做的条件判断，就等于是在给树**剪枝**。

而括号生成的[这个答案](https://leetcode.cn/problems/generate-parentheses/solution/hui-su-suan-fa-by-liweiwei1419/)说的特别好——**无论我们选择深度优先还是广度优先，无非是在考虑如何去遍历这棵树**！
1. 深度优先（回溯）就是在**使用系统栈的深度做优先遍历**（所以我们看它的空间复杂度分析，如果每层都是O(1)，那空间复杂度就是栈的层数O(k)）；
2. 我们也可以**自己使用栈编写深度优先遍历**（这时候空间复杂度就很明显了，就是我们所用的栈O(k)）；
3. **而广度优先遍历，其实是程序猿自己编写节点类，使用队列存储这个数据结构**；

因此**核心在于心中要有那棵树！**

关于剪枝：如果不让结果有重复值，那么一般需要先排个序，然后**考虑相同元素直接跳过**！关于重复元素的过滤，**提前剪枝比在最后结果里去重要好得多**！因为少了无数的递归运算！比如[组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)，**如果不剪枝而是想生成所有结果之后再去做去重处理，会被这个用例卡超时**：
```
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
30
```

注意：**“提前剪枝”的“提前”指的是“不要让某些显然已经不符合条件的分支一直递归下去”，至于是进入下一个dfs函数之后剪（采用return），还是在进入下一个dfs函数之前剪（采用if语句跳过），没什么区别，前者只是比后者多进入了一层函数，但都属于“提前”剪枝**。

相关题目：
- [括号生成](https://leetcode.cn/problems/generate-parentheses/solution/gua-hao-sheng-cheng-by-leetcode-solution/)
- [电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solution/dian-hua-hao-ma-de-zi-mu-zu-he-by-leetcode-solutio/)
- [路径总和II](https://leetcode.cn/problems/path-sum-ii/)

系列：
- [组合总和](https://leetcode.cn/problems/combination-sum/)
- [组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)
- [组合总和 III](https://leetcode.cn/problems/combination-sum-iii/)
- [组合总和 IV](https://leetcode.cn/problems/combination-sum-iv/)

回溯的题型列表可以参考[这里](https://leetcode.cn/problems/subsets-ii/solutions/690866/90-zi-ji-iiche-di-li-jie-zi-ji-wen-ti-ru-djmf/)的整理。

## 退回来怎么退？恢复现场！
**回退的时候，其实就是要恢复上一次试探前的现场**。

比如常见的生成字符串，“现场”就是当前已经记录的字符集合，那么就要看字符是append到当前集合还是重新new了一个新集合：
1. 进入下一层的时候，**如果没有污染当前字符集合（new），则方法返回的时候已经是回退了**；
2. 进入下一层的时候，如果当前集合被污染了（append），则方法返回后要把当前数据修改为原样，一般是一个delete操作；

第一种情况比如括号生成：这种写法里，传参用的是新string，不影响当前string；如果用`StringBuilder`，就会影响。
```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> result = new ArrayList<>();
        // dfs真好用……
        // 剪枝，第一个一定是(
        dfs(result, "(", n, 1, 0);
        return result;
    }

    private void dfs(List<String> result, String curString, int n, int left, int right) {
        // 剪枝，最后一个一定是)
        if (curString.length() == n * 2 - 1) {
            result.add(curString + ')');
        } else {
            // 剪枝，中间如果已经不满足了，就别搞了
            if (left < n) {
                dfs(result, curString + '(', n, left + 1, right);
            }
            if (right < left && right < n - 1) {
                dfs(result, curString + ')', n, left, right + 1);
            }
        }
    }
```

第二种情况比如电话号码的字母组合：这种写法没有用新string，而是用了`StringBuilder`，就影响了当前`StringBuilder`的值。
```java
class Solution {
    public List<String> letterCombinations(String digits) {
        List<String> combinations = new ArrayList<String>();
        if (digits.length() == 0) {
            return combinations;
        }
        Map<Character, String> phoneMap = new HashMap<Character, String>() {{
            put('2', "abc");
            put('3', "def");
            put('4', "ghi");
            put('5', "jkl");
            put('6', "mno");
            put('7', "pqrs");
            put('8', "tuv");
            put('9', "wxyz");
        }};
        backtrack(combinations, phoneMap, digits, 0, new StringBuffer());
        return combinations;
    }

    public void backtrack(List<String> combinations, Map<Character, String> phoneMap, String digits, int index, StringBuffer combination) {
        if (index == digits.length()) {
            combinations.add(combination.toString());
        } else {
            char digit = digits.charAt(index);
            String letters = phoneMap.get(digit);
            int lettersCount = letters.length();
            for (int i = 0; i < lettersCount; i++) {
                combination.append(letters.charAt(i));
                backtrack(combinations, phoneMap, digits, index + 1, combination);
                combination.deleteCharAt(index);
            }
        }
    }
}
```
使用string的时候，更简洁：
```java
class Solution {

    Map<Character, String> phoneMap = new HashMap<Character, String>() {{
        put('2', "abc");
        put('3', "def");
        put('4', "ghi");
        put('5', "jkl");
        put('6', "mno");
        put('7', "pqrs");
        put('8', "tuv");
        put('9', "wxyz");
    }};

    public List<String> letterCombinations(String digits) {
        List<String> result = new ArrayList<>();

        if (digits.length() == 0) {
            return result;
        }

        dfs(result, 0, "", digits);
        return result;
    }

    private void dfs(List<String> result, int step, String buffer, String digits) {
        if (digits.length() == step) {
            result.add(buffer);
            return;
        }

        String conditions = phoneMap.get(digits.charAt(step));
        for (int i = 0; i < conditions.length(); i++) {
            dfs(result, step + 1, buffer + conditions.charAt(i), digits);
        }
    }
}
```
对于其他情况，原则是一样的，“恢复现场”，但是实践起来会有所区别。

比如[不同路径 III](https://leetcode.cn/problems/unique-paths-iii/description/)，**只有在当前格子探索完了之后（从当前格子的上下左右方向都试探了），返回上级之前，才需要恢复现场**，所以return之前要reset：
```java
class Solution {
    public int uniquePathsIII(int[][] grid) {
        int row = grid.length, col = grid[0].length;

        int length = 0, si = -1, sj = -1;
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (grid[i][j] == 0) {
                    length++;
                }

                if (grid[i][j] == 1) {
                    si = i;
                    sj = j;
                }
            }
        }

        // 要经过length个0，那么需要length+1步才能到达重点
        return dfs(grid, length + 1, 0, si, sj);
    }

    // step: cur step number
    private int dfs(int[][] grid, int length, int step, int i, int j) {
        // border
        if (i >= grid.length || i < 0 || j >= grid[0].length || j < 0) {
            return 0;
        }

        // result
        if (step == length) {
            return grid[i][j] == 2 ? 1 : 0;
        }

        // obstacle
        if (grid[i][j] == -1 || grid[i][j] == 2) {
            return 0;
        }

        // already walked
        if (grid[i][j] > 10) {
            return 0;
        }

        // mark
        grid[i][j] += 20;

        int a = dfs(grid, length, step + 1, i + 1, j);
        // reset(grid, i + 1, j);
        int b = dfs(grid, length, step + 1, i, j + 1);
        // reset(grid, i, j + 1);
        int c = dfs(grid, length, step + 1, i - 1, j);
        // reset(grid, i - 1, j);
        int d = dfs(grid, length, step + 1, i, j - 1);
        // reset(grid, i, j - 1);
        
        // 只有上下左右都探索完了，才需要回，所以应该在这里reset，而不是每一步之后
        reset(grid, i, j);

        return a + b + c + d;
    }

    private void reset(int[][]grid, int i, int j) {
        if (i >= grid.length || i < 0 || j >= grid[0].length || j < 0) {
            return;
        }

        if (grid[i][j] > 10) {
            grid[i][j] -= 20;
        }
    }
}
```
一开始想错在了两个地方，看注释掉的代码就能看出来：
1. 不用考虑reset**下一步**里染色过的格子（属于是**逻辑混乱**了），只需要考虑**当前步骤**的回退工作，那么下一步回退的时候，**自然会**reset好它们那层的状态；
2. 只考虑reset当前格子，就会发现上下左右每次探索前都需要染色当前格子，那么每一次回溯后就不需要动当前格子，只有最后要出这一层的时候，才需要reset。

由于是最后才需要回溯一次，而不是每一次都回溯，所以回溯也不用这么麻烦（+20，判断>+10），只需要一开始记录下当前值，退出前set回去就行了。比如[官方答案](https://leetcode.cn/problems/unique-paths-iii/solutions/2365866/bu-tong-lu-jing-iii-by-leetcode-solution-cndw/)：
```java
class Solution {
    static int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

    public int uniquePathsIII(int[][] grid) {
        int r = grid.length, c = grid[0].length;
        int si = 0, sj = 0, n = 0;
        for (int i = 0; i < r; i++) {
            for (int j = 0; j < c; j++) {
                if (grid[i][j] == 0) {
                    n++;
                } else if (grid[i][j] == 1) {
                    n++;
                    si = i;
                    sj = j;
                }
            }
        }
        return dfs(grid, si, sj, n);
    }

    public int dfs(int[][] grid, int i, int j, int n) {
        if (grid[i][j] == 2) {
            return n == 0 ? 1 : 0;
        }
        int r = grid.length, c = grid[0].length;
        int t = grid[i][j];
        grid[i][j] = -1;
        int res = 0;
        for (int[] dir : dirs) {
            int ni = i + dir[0], nj = j + dir[1];
            if (ni >= 0 && ni < r && nj >= 0 && nj < c && (grid[ni][nj] == 0 || grid[ni][nj] == 2)) {
                res += dfs(grid, ni, nj, n - 1);
            }
        }
        grid[i][j] = t;
        return res;
    }
}
```

> 其实[路径总和 II](https://leetcode.cn/problems/path-sum-ii/description/)也类似，最后才reset。

和字符串回溯问题相比，[不同路径 III](https://leetcode.cn/problems/unique-paths-iii/description/)很有意思，**区别点在于context的有状态性**：
- 字符串回溯，context是字符串，当前层每一种情况回溯过后（恢复完context），字符串也是干净的，最后就可以直接退出了；
- 这个题，context是原始二维数组，当前层每一种情况回溯过后，**最后要来个总的context reset行为**，恢复原始二维数组，才能退出；**如果每次进入下一层，用的是新new的二维标记数组，就不需要考虑这一步了，但是那样传参的时候就太麻烦了**。

> 和下面岛屿问题的区别在于，岛屿问题只染色，不清除，直接回溯；这个是需要清除标记的，所以是更纯粹的回溯问题。

## 回溯一种情况之后该做什么
**这个很重要！一般一段时间不写回溯后，就会卡在这里！回溯之后干什么？当然是继续枚举其他情况。怎么枚举？**

比如上述括号生产，总共就两种情况：
- 先试左括号
- 再试右括号

**这种情况直接写两个回溯即可**。

对于电话号码的字母组合，**每一个字母都对应k种情况（k为当前数字对应的字母的个数），这时候就应该用for循环，循环每一种情况去写回溯**。

## dfs模板
所以回溯问题的模板就是：
```java
dfs:
    不符合？（这也是在剪枝，进入下一层dfs后的剪枝）
        return

    终结条件？
        收集结果
        return
        
    如果符合情况（剪枝，进入下一层dfs前的剪枝）：
        获取下一步里所有的情况（k个）
        for i in k：
            dfs（枚举每一种情况）
            回来了：如果污染了，就把数据处理回来，否则for循环里啥也不用写，就可以进行下一种情况了
            
        # 如果context依然不干净（eg：二维数组标记），也可能需要在所有探索分支都reset之后，最后再来个reset行为
```
建议先写不符合条件时的return，再写满足结果时收集结果的return。


**注意：如果k很小，就不要用for了。比如二叉树，或者图遍历，直接枚举2、4种情况就行了！**

### dfs参数列表
**另一个问题就是，dfs函数的参数都应该是什么**？这个主要就是看需要什么：
- list：收集结果
- step
- 当前生成中的数据
- n：最长多少步。因为要知道什么时候终结

其他数据看情况，需要就加进来。

**比如上述括号生成，当前有多少个左括号和右括号是需要用到的数据，就放入参数列表直接传进去，免得再统计了。**

比如下述路径总和II，当前所有值的sum就是必要信息（当然用减法似乎更好一些，防止溢出的情况），**不然每一步里都得算。这样的话sum也应该作为参数**。

### 用模板去写
比如按照模板写上述电话号码字母组合——
1. dfs参数用了String digits，因为要知道当前这一步的数字，才能找到对应的字母。同时它隐含了n的信息（`digits.length()`），所以就不用传n了；
2. 找到对应的字母之后，for循环试探每一种情况就行了；
3. 因为生成中的数据用的是string而非stringbuilder，所以不会污染当前生成中的数据，回溯后就不用考虑擦除了；
```java
class Solution {

    Map<Character, String> phoneMap = new HashMap<Character, String>() {{
        put('2', "abc");
        put('3', "def");
        put('4', "ghi");
        put('5', "jkl");
        put('6', "mno");
        put('7', "pqrs");
        put('8', "tuv");
        put('9', "wxyz");
    }};

    public List<String> letterCombinations(String digits) {
        List<String> result = new ArrayList<>();

        if (digits.length() == 0) {
            return result;
        }

        dfs(result, 0, "", digits);
        return result;
    }

    void dfs(List<String> result, int step, String buffer, String digits) {
        if (digits.length() == step) {
            result.add(buffer);
            return;
        }

        String conditions = phoneMap.get(digits.charAt(step));
        for (int i = 0; i < conditions.length(); i++) {
            dfs(result, step + 1, buffer + conditions.charAt(i), digits);
        }
    }
}
```
或者：
```java
            // 小剪枝：同一层相同数值的结点，从第 2 个开始，候选数更少，结果一定发生重复，因此跳过，用 continue
            if (i > begin && candidates[i] == candidates[i - 1]) {
                continue;
            }
```
## 再说剪枝
我觉得dfs有三大麻烦的地方：
1. dfs的模板。没模板是没法写的，但我们已经总结出来了；
2. dfs方法参数列表：上面总结的几个参数是关键参数，其他看情况决定加不加；
3. 剪枝：**上面两步相对固定，也相对好搞定。最灵活的当属剪枝了，很多时候，一个题能不能过，就看需不需要剪枝，好不好剪枝**。
    1. 上述电话号码组合字母，压根不需要剪枝，所有的情况都是符合的，最简单；
    2. 上述括号生成，剪枝的条件稍微麻烦一些：左括号不能多余n，右括号不能多于左括号；

再看[组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)，更麻烦！因为结果不能重复，前一个结果里用了那个1，后一个结果里用了这个1，是不行的。如果想逃避剪枝，比如把结果全都收集起来再去重，也是不行的，因为会被一个全是1的用例卡超时，它就是为了让你绕不过剪枝，只能剪枝。

**这个时候如果能想到先排个序，然后“同层相同元素”只用一个，就能剪掉不少枝！**

> **同层指：比如1, 2, 2, 2，如果第一个2是上层探索的，那么这一层可以用第二个2；如果这层已经用了2，如果后面还有2，本层不要再用2，否则“本层用第一个2”就和“本层用第二个2”重复了。**

```java
class Solution {
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        // 不能包含重复解，但是候选数字本身有重复，所以要排个序，方便跳过
        Arrays.sort(candidates);

        List<List<Integer>> result = new ArrayList<>();
        dfs(result, candidates, target, new ArrayList<>(), 0);
        return result;
    }

    // 传入start，是因为要求结果无重复
    private void dfs(List<List<Integer>> result, int [] candidates, int target, List<Integer> context, int start) {
        if (target == 0) {
            result.add(new ArrayList<>(context));
            return;
        }

        if (target < 0) {
            return;
        }

        // 结果无重复，所以只能一直往后找，因此不能一直从0开始找
        for (int i = start; i < candidates.length; i++) {
            int value = candidates[i];

            // 本层的重复数字不能重复用，不同层的数字可以重复
            // 所以前一个数字必须得在本层（i-1>=start），才去判断当前值是否要跳过
            if (i - 1 >= start && value == candidates[i - 1]) {
                continue;
            }

            context.add(value);
            // 因为数字不可以重复用，所以下一个是从i+1开始探索
            dfs(result, candidates, target - value, context, i + 1);
            context.removeLast();
        }
    }
}
```
但是如果想不到排序，剪枝将会非常麻烦！比如我这个：
```java
    void dfs(List<List<Integer>> result, int step, int[] candidates, int sum, List<Integer> cur, int target) {
        if (sum > target) {
            return;
        }

        if (sum == target) {
            result.add(new ArrayList<>(cur));
            return;
        }

        for (int i = step; i < candidates.length; i++) {
            int next = candidates[i];

            // 之前有过这个数，当前的候选集里还没用过，咱也别用了：
            // 要么它不符合条件，咱也别忙活了
            // 要么它符合条件，用过了，再要这个就重复了
            boolean skip = false;

            int sameValue = 0;
            for (int j = 0; j < i; j++) {
                if (candidates[j] == next) {
                    sameValue++;
                }
            }

            int using = 0;
            for (Integer integer : cur) {
                if (integer == next) {
                    using++;
                }
            }

            // 比如之前出现过两次，现在已经用了一次了，别再放第二次了，再放也是重复
            if (using < sameValue) {
                continue;
            }

            cur.add(next);
            dfs(result, i + 1, candidates, sum + next, cur, target);
            cur.removeLast();
        }
    }
```
**所以剪枝确实很考验思维。我们也应该记住，修改（比如sort）源数据是个可以考虑的方案。**

## 题目类型：子集
单独[子集](https://leetcode.cn/problems/subsets/description/)类型的题目拉出来，是因为发现时隔不久之后，**再写回溯的时候就“心中没树”了**！所以再拉出来把解题模板强化一遍。

子集这道题的[官方解法](https://leetcode.cn/problems/subsets/solutions/420294/zi-ji-by-leetcode-solution/)比较正统一些：每一个位置可以选或不选，就像二叉树一样，所以用两个dfs，结束条件是遍历到了集合的最后一个元素。
```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        dfs(result, 0, new ArrayList<>(), nums);

        return result;
    }

    private void dfs(List<List<Integer>> result, int i, List<Integer> cur, int[] nums) {
        if (i == nums.length) {
            result.add(new ArrayList<>(cur));
            return;
        }

        int curInteger = nums[i];
        cur.add(curInteger);
        // with cur integer
        dfs(result, i + 1, cur, nums);
        cur.removeLast();

        // without cur integer
        dfs(result, i + 1, cur, nums);
    }
}
```
关键点还是那句话：心中有树！

而我写了一个很抽象的解法：dfs负责取长度为k的元素集合。由于是子集，所以k可以从0（空集）到n（全集）。
```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        int n = nums.length;
        for (int i = 0; i <= n; i++) {
            dfs(result, new ArrayList<>(), 0, nums, i);
        }
        return result;
    }

    private void dfs(List<List<Integer>> result, List<Integer> cur, int start, int[] nums, int k) {
        if (cur.size() == k) {
            result.add(new ArrayList<>(cur));
            return;
        }

        int n = nums.length;
        if (start >= n) {
            return;
        }

        for (int i = start; i < n; i++) {
            int curNum = nums[i];
            cur.add(curNum);
            dfs(result, cur, i + 1, nums, k);
            cur.removeLast();
        }
    }
}
```

在我的解法里，遍历的时候用了for，**代表当前节点可以有[start, n)种选择**：
- 如果使用了当前i，代表不跳过第i个元素；
- 回溯之后（删掉字符，代表不使用第i个元素），再i++后，就相当于跳过了第i个元素；

这个思路现在来看依然是有点儿抽象的。相当于每一步都在全排列，最终能生成长度为k的子数组就要，否则就当组错了，丢弃。**我觉得这是一种for的误用，多回溯了很多种情况，只不过最后使用cur.size() == k把不符合条件的结果都过滤了**。

比如继续看[字母大小写全排列](https://leetcode.cn/problems/letter-case-permutation/description/)，如果用类似上述官解的思路就比较简单：字母分为大小写，所以是二叉，数字没有变形，所以是单叉：
```java
class Solution {
    public List<String> letterCasePermutation(String s) {
        List<String> result = new ArrayList<>();
        dfs(result, "", 0, s);
        return result;
    }

    private void dfs(List<String> result, String cur, int start, String raw) {
        int n = raw.length();
        if (cur.length() == n) {
            result.add(cur);
            return;
        }

            int i = start;
        // 压根不需要for，因为每一个字符都得用上
        // for (int i = start; i < n; i++) {
            char c = raw.charAt(i);
            if (Character.isDigit(c)) {
                // 这里是单叉数
                dfs(result, cur + c, i + 1, raw);
            } else {
                // 像是一颗二叉树，在这里发生了分叉，每一个分支遍历到
                dfs(result, cur + Character.toLowerCase(c), i + 1, raw);
                dfs(result, cur + Character.toUpperCase(c), i + 1, raw);
            }
        // }
    }
}
```
也不需要for。虽然最终结果对了，**但全靠size == n给过滤的，实际上for i++之后，相当于没使用当前字符，这样最终字符串长度肯定不对，相当于多了很多无效回溯，所以最终代码只击败了5%的人。去掉for后，击败了23%，从99ms降到了7ms，快了非常多**。之所以才23%，应该用sb会比用string快，毕竟2^n的复杂度，多生成了很多string对象。
```java
class Solution {
    public List<String> letterCasePermutation(String s) {
        List<String> result = new ArrayList<>();
        dfs(result, "", 0, s);
        return result;
    }

    private void dfs(List<String> result, String cur, int start, String raw) {
        int n = raw.length();
        if (cur.length() == n) {
            result.add(cur);
            return;
        }

        for (int i = start; i < n; i++) {
            char c = raw.charAt(i);
            if (Character.isDigit(c)) {
                // 这里是单叉数
                dfs(result, cur + c, i + 1, raw);
            } else {
                // 像是一颗二叉树，在这里发生了分叉，每一个分支遍历到
                dfs(result, cur + Character.toLowerCase(c), i + 1, raw);
                dfs(result, cur + Character.toUpperCase(c), i + 1, raw);
            }
        }
    }
}
```

**什么时候用for来着？比如电话号码的字母组合，每一个节点有k种决策，且k个数不定，用for写比较好。如果k个数确定（比如二叉树2个，或者图遍历4个方向），就可以不用for，直接全枚举出来。**

再回头看子集，为什么for也行，枚举二叉树的每一个分支也行？因为每一个节点都可要可不要，这个时候有不同的实现方式：
1. 官方视角里，“可要可不要”就是每一个节点做两种决策，最终遍历到最后一个字符，所有情况就都收集了；
1. 我的那个解法的视角里，“可要可不要”是通过for来做的，i++的时候，就是说在这个节点上没有要i。但实际上因为用了for，我的每一个节点都在做类似全排列的事情。

总体来说，结果对了，不代表整个试探过程是有效的。可能像我一样在做瞎试探，最终只取了符合条件的，结果依然对，但实际瞎试探了非常多种情况。

[子集 II](https://leetcode.cn/problems/subsets-ii/description/)可以用同样的思路，不过在剪枝方面会比较麻烦。比如1, 2, 2, 2，对于这一连串2，可以选择0/1/2/3个，分别构成不同的子集。怎么避免出现[1, 第一个2]，[1, 第二个2]这种重复结果呢？
1. **如果前一个和当前数字相同，且前一个没选，则当前也不要选**！这样可以避免重复。
1.  如果前一个选了，当前可选可不选：如果选了，就是两个2，符合子集；如果不选，就是一个2，结合第一条规则，后面的2都不会被选，所以就是只有一个2的子集；

这样，所有的0/1/2/3个2的情况都被考虑到了：
```java
class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        // sort
        Arrays.sort(nums);

        List<List<Integer>> result = new ArrayList<>();
        dfs(result, 0, new ArrayList<>(), nums, false);

        return result;
    }

    private void dfs(List<List<Integer>> result, int i, List<Integer> cur, int[] nums, boolean choosePre) {
        if (i == nums.length) {
            result.add(new ArrayList<>(cur));
            return;
        }

        int curInteger = nums[i];

        // 如果前一个数和我相同，且没选，那我一定不选
        if (i > 0 && curInteger == nums[i - 1] && !choosePre) {
            // without cur integer
            dfs(result, i + 1, cur, nums, false);
            return;
        }

        // 否则我可选可不选
        
        cur.add(curInteger);
        // with cur integer
        dfs(result, i + 1, cur, nums, true);
        cur.removeLast();

        // without cur integer
        dfs(result, i + 1, cur, nums, false);
    }
}
```
> 这个题的去重还有比较狗的地方：因为题目给出了限定，元素最多有10个，所以可以暴力dfs所有可能，然后使用set去重（`Set<List<Integer>> result`）。为了set去重方便，可以给原数组排序，这样所有子集都是单调的，相同子集就会只留一个。**如果实在想不出来怎么剪枝，可以结合题目规模，考虑这种方案。**

这个题的剪枝和[组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)有点儿像又不一样：
- [组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)是每一层都有多个选择，如果上一层选了，本层可选可不选；但本层如果选了，本层后面的决策一定不要再选了；
- 本题每一层只有两个选择，如果上一层选了，本层可选可不选；但如果上一层没选，本层一定不要选了；

# 从图的角度再理解DFS和BFS
dfs和bfs在树里很常用。但是，在网格里二者也很常用！**只不过树天然是有向图，不会重复，但是格子是无向图，所以网格的遍历要有目的性，需要进行标记，代表来过，如果不标记，会重复走回去**。

## DFS与网格
比如[岛屿周长](https://leetcode.cn/problems/island-perimeter/solution/tu-jie-jian-ji-er-qiao-miao-de-dfs-fang-fa-java-by/)，就是dfs走遍一个岛屿。

这些dfs算法可以为我们上面的dfs补充一些知识：
1. **格子的dfs就四种情况，for循环或者直接写都行**；
1. **先判断再决定是否进入dfs？还是先进去，不满足再返回？都行**。上面的组合总和II里的sum我们用的是后者，岛屿问题这里用的也是后者，因为这样判断起来更简单；
1. **如果dfs本身无限重复递归，或者从形象的角度来说会走重复的路，不像树一样是有向无环的，那我们就手动给它加个界（染色标记）**；

这样岛屿的周长就迎刃而解了：
```java
public int islandPerimeter(int[][] grid) {
    for (int r = 0; r < grid.length; r++) {
        for (int c = 0; c < grid[0].length; c++) {
            if (grid[r][c] == 1) {
                // 题目限制只有一个岛屿，计算一个即可
                return dfs(grid, r, c);
            }
        }
    }
    return 0;
}

int dfs(int[][] grid, int r, int c) {
    if (!(0 <= r && r < grid.length && 0 <= c && c < grid[0].length)) {
        return 1;
    }
    if (grid[r][c] == 0) {
        return 1;
    }
    if (grid[r][c] != 1) {
        return 0;
    }
    grid[r][c] = 2;
    return dfs(grid, r - 1, c)
        + dfs(grid, r + 1, c)
        + dfs(grid, r, c - 1)
        + dfs(grid, r, c + 1);
}
```
**这里没有使用result去收集结果，因为就一个值。把每一种dfs收集到的结果（每一个方向的探索结果）加起来即可，就和求树的高度/叶子节点的个数一样。**

**岛屿问题的难点在于问题的转化：如何把所求内容转化为和DFS/BFS相关的问题**。
- 岛屿周长：从某个1开始DFS，如果拓展的该方向上的下一个是0，就是周长，记录个1（上述解法中，是return 1）；
- [岛屿数量](https://leetcode.cn/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/)：从某个1开始DFS，消除所达之处所有的1，看能这么玩几次，就说明有几个岛屿；
- [最大的岛屿的面积](https://leetcode.cn/problems/max-area-of-island/)：和岛屿数量一样，其实就是在消除一个岛屿的时候，记录下该岛屿的面积，最后求个max（求岛屿面积和求周长是一样的，也是四个方向上探索结果的累加）；

最大的岛屿的面积：
```java
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int row = grid.length;
        int col = grid[0].length;

        int max = 0;
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (grid[i][j] == 1) {
                    max = Math.max(max, dfs(grid, i, j));
                }
            }
        }
        return max;
    }

    private int dfs(int[][] grid, int x, int y) {
        int row = grid.length;
        int col = grid[0].length;
        if (x < 0 || x >= row || y < 0 || y >= col) {
            return 0;
        }

        if (grid[x][y] == 0 || grid[x][y] == 2) {
            return 0;
        }

        // 到此一游
        // 直接标记为0也行，相当于把岛屿抹去了，反正也用不到了
        grid[x][y] = 2;
        
        return 1 + dfs(grid, x - 1, y)
        + dfs(grid, x + 1, y)
        + dfs(grid, x, y - 1)
        + dfs(grid, x, y + 1);
    }
}
```

## BFS与网格 - 层序遍历/最短路径
bfs遍历图的方式，其实和遍历树的方式差不多：
- **每一个符合条件的点都作为root，加入队列**；
- 依次pop队列，每一个pop出来的点拓展出上下左右四个点，如果满足条件，再加入队列；
- 当然，**拓展点的时候也要做标记，因为是多个root，防止冲突扩散**；

从[题解](https://leetcode.cn/problems/as-far-from-land-as-possible/solutions/176105/jian-dan-java-miao-dong-tu-de-bfs-by-sweetiee/)中可以看出来，如果抽象能力再强一些，可以很容易看出**图和树在BFS上的共同点：**
- **单源多源**：tree只有1个root，而图可以有多个源点，所以首先需要把多个源点都入队。
- **有向无向**：tree是有向的因此不需要标志是否访问过，而对于无向图来说，必须得标志是否访问过！并且为了防止某个节点多次入队，需要在入队之前就将其设置成已访问！

BFS和DFS都能遍历所有节点。在掌握dfs之后，发现dfs其实比bfs更好写。那为什么要用BFS？在[BFS 的使用场景总结](https://leetcode.cn/problems/binary-tree-level-order-traversal/solution/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l/)里说的很好，**bfs有dfs没有的两个优势**：
1. **层序遍历**；
2. **最短路径**；

层序遍历自不必说，必须层序输出一个树的节点，只有bfs能做到。另一个点比较难注意：**bfs更适用于那些求距离的题目**，比如[离陆地最远的海洋](https://leetcode.cn/problems/as-far-from-land-as-possible/solution/jian-dan-java-miao-dong-tu-de-bfs-by-sweetiee/)，怎么转化呢？
- 从每一个1出发，开始BFS，看最远被标记到的数是几。bfs是同时走的，和dfs不一样，不是先让一个root走到头；

```java
class Solution {
    public int maxDistance(int[][] grid) {
        // 用数组表示点的横纵坐标
        Deque<int[]> queue = new ArrayDeque<>();

        int row = grid.length;
        int col = grid[0].length;

        // 把陆地加入队列，一层层遍历
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (grid[i][j] == 1) {
                    queue.offer(new int[]{i, j});
                }
            }
        }

        // 特例，没有海洋
        if (queue.size() == row * col) {
            return -1;
        }

        int[] x = new int[] {-1, 1, 0, 0};
        int[] y = new int[] {0, 0, -1, 1};

        int distance = 0;
        while (!queue.isEmpty()) {
            distance++;
            int size = queue.size();
            while (size-- > 0) {
                int[] point = queue.poll();
                for (int i = 0; i < 4; i++) {
                    int a = point[0] + x[i];
                    int b = point[1] + y[i];
                    if (a < 0 || a >= row || b < 0 || b >= col) {
                        continue;
                    }

                    // 新的海洋
                    if (grid[a][b] == 0) {
                        // 标记来过
                        grid[a][b] = distance;
                        queue.offer(new int[] {a, b});
                    }
                }
            }
        }

        return distance - 1;
    }
}
```
**这个是多源bfs，但是无论是一个点的bfs还是多个点的bfs，本质上没有区别。毕竟单个点的bfs从第二层开始，也变成多点了嘛！**

但并不是所有的bfs都和最短路径配合。比如[最小高度树](https://leetcode.cn/problems/minimum-height-trees/)，**如果单从一个点看，求一棵树的最小高度直接用的是bfs最短路径。但是如果求全局的最小，其实是每次从叶节点bfs到最中间的核心点，此时每次入队的不是临近节点，而是新的度为1的节点**。

### bfs与Dijkstra
说到最短路径，就想到Dijkstra，二者的区别在于：**bfs只适合求没有权重时候的最短路径，权重不同时还得看迪杰斯特拉！**

# 从树的角度再理解DFS和BFS
从树的角度，再来看看这两个算法。

**bfs更适用于层级关系的解法。比如求树某一层的深度（不是高度）；涉及到[二叉树的堂兄弟节点](https://leetcode.cn/problems/cousins-in-binary-tree-ii/description/)等。**

## 树的DFS只是DFS的一个特例
当通过上面的训练掌握了dfs，甚至总结出了dfs的模板的时候，**就会发现树的dfs只是dfs这个模板下的一个很小的特例：一个每次仅有两个选择的dfs而已**。所以在这个模板里**用不到for循环去试探每一种情况，只需要把两种情况都写出来就行了**！
```java
void dfs(TreeNode root) {
    // 终结条件？
    
    // dfs选择1
    dfs(root.left);
    // 回溯，再dfs选择2
    dfs(root.right);
    // 又回溯
}
```

这个时候再看[写树算法的套路框架](https://leetcode.cn/problems/same-tree/solution/xie-shu-suan-fa-de-tao-lu-kuang-jia-by-wei-lai-bu-/)，就显得很容易了。牢记这一点：**树的dfs就是dfs的一种只有两种选择的特例而已**。

当时我看到上述模板在讨论[验证BST](https://leetcode.cn/problems/validate-binary-search-tree/)时，很喜欢一个观点：
> 出现错误，不要慌张，框架没有错，一定是某个细节问题没注意到。我们重新看一下 BST 的定义，**root 需要做的不只是和左右子节点比较，而是要整个左子树和右子树所有节点比较。怎么办，鞭长莫及啊！这种情况，我们可以使用辅助函数，增加函数参数列表，在参数中携带额外信息**。

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        // 竟然卡int的边界值……
        return inBoundary(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }

    private boolean inBoundary(TreeNode root, long low, long high) {
        if (root == null) {
            return true;
        }

        // woc, BST的定义是左子树必须都小于跟，而不是小于等于；右侧同理
        if (root.val <= low || root.val >= high) {
            return false;
        }

        return inBoundary(root.left, low, root.val) && inBoundary(root.right, root.val, high);
    }
}
```
但是当我们意识到树的dfs只是“dfs的一种只有两种选择的特例而已”的时候，就会觉得这句话也不过如此了，**毕竟在讨论通用dfs的时候就发现了，选择什么作为参数列表，本来就是根据需要来的。所以这里给函数加个min/max，很稀松平常，需要就加呗**。

> 但是以前没把树的dfs和通用dfs紧密联系起来的时候，只是记住了树的dfs的大致样子，导致每次看到给树的dfs加参数的操作，总觉得很精妙。现在看来不过如此。

再举一个类似的例子：[路径总和](https://leetcode.cn/problems/path-sum/)，当前路径的sum是要一路传下去的。这和上面的组合总和II一样，参数列表里要加个参数把当前遍历到的元素的sum传下去而已。

## 二叉搜索树BST的DFS：做了剪枝的DFS
既然树的dfs是dfs的特例，那么bst的dfs更是特例中的特例。

**此时再看bfs的查找算法，就是一个加上了限制条件的回溯。其实就是相当于我们拿bst固有的节点大小特性来给普通dfs做了剪枝**：
```java
boolean isInBST(TreeNode root, int target) {
    if (root == null) return false;
    if (root.val == target)
        return true;
    if (root.val < target) 
        return isInBST(root.right, target);
    if (root.val > target)
        return isInBST(root.left, target);
}
```
**没利用上bst的大小关系，写出来的就是没剪枝的dfs，普通二叉树的dfs**：
```java
boolean isInBST(TreeNode root, int target) {
    if (root == null) return false;
    if (root.val == target) return true;

    return isInBST(root.left, target)
        || isInBST(root.right, target);
}
```

## DFS结果的收集方式
之前的通用dfs模板讨论主要讨论了：
- 终结条件
- 情况选择
- 剪枝
- 参数列表

但其实还有一个比较重要的考量：返回类型。通用dfs里，一般求的是结果集，所以通过把result list作为参数传入下一层dfs去收集结果，此时返回值只需要设为null。

但是树和图不一定是这样：
- 求的是一个数：
    - 岛屿周长/面积：各个方向（4个方向）上的值累加起来即可；
    - 数的叶子结点个数：每个方向（左、右）的叶子加起来即可；
    - 数的高度：每个方向的高度的max；

虽然只要传入一个类似atomic integer的参数就和传入result list一样了，但是更优雅的方式应该是让dfs return一个数，然后reduce（累加/max等）

- 求的是一棵树。比如下面的题。

比如[bst中插入一个数](https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/)。从通用dfs的角度来看，就是在思考**它怎么转化为一个dfs的问题**？dfs到一个null节点的时候，就是可以插入的地方。返回的是root，所以我们**在dfs的时候把root类比为result list的角色，把它作为参数传进dfs函数**，最后返回root就行了：
```java
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if (root == null) {
            return new TreeNode(val);
        }

        dfs(root, val);
        return root;
    }

    // 以通用dfs的思路去插入bst，此时root相当于result，是结果收集者
    void dfs(TreeNode root, int val) {
        if (val < root.val) {
            if (root.left == null) {
                root.left = new TreeNode(val);
            } else {
                dfs(root.left, val);
            }
        }

        if (val > root.val) {
            if (root.right == null) {
                root.right = new TreeNode(val);
            } else {
                dfs(root.right, val);
            }
        }
    }

}
```

> null情况在进入dfs之前去处理，dfs函数本身不处理null。

**以通用dfs的思维去思考，非常简单！但是和上面“求的是一个数”的例子类似，这样写稍显啰嗦，我还是推荐尝试优化一下返回值，至少对思维训练很有帮助！**

由于返回的是单元素TreeNode（类似单元素int），我们应该像直接renturn int，最后再去reduce一样，考虑return TreeNode。

```java
TreeNode insertIntoBST(TreeNode root, int val) {
    // 找到空位置插入新节点
    if (root == null) return new TreeNode(val);
    
    // if (root.val == val)
    //     BST 中一般不会插入已存在的元素
    
    if (root.val < val) 
        root.right = insertIntoBST(root.right, val);
        
    if (root.val > val) 
        root.left = insertIntoBST(root.left, val);
        
    return root;
}
```
确实困难很多。

另一个角度就是记住bst的模板。**虽然从抽象的角度认识到它只是通用bfs的一个特例对理解它很有帮助，但是记住这个特例模板也非常重要**——BST 中的遍历框架，就是“找”的问题。直接套框架，加上“改”的操作即可。一旦涉及“改”，函数就要返回 TreeNode 类型，**并且对递归调用的返回值进行接收**。

> 认识到它符合抽象性，同时记住它有独特性。

## 左右子树组合/切分
悟了上面这一点，就能写出[前序+中序构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)、[中序+后续构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)，虽然它不是bst，但是用了上面左右子树切分、组合的思想：
```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return build(preorder, 0, inorder, 0, preorder.length - 1);
    }

    // 每当需要二分的时候，用左右start、end就行了
    // preorder只判断root
    // inorder才是做左右切分的那个，所以start、end代表的是inorder的下标
    private TreeNode build(int[] preorder, int rootIndexInPreorder, int[] inorder, int start, int end) {
        if (start > end) {
            return null;
        }
        int rootVal = preorder[rootIndexInPreorder];
        TreeNode root = new TreeNode(rootVal);

        int rootIndexInInorder = -1;
        for (int i = start; i <= end; i++) {
            if (inorder[i] == rootVal) {
                rootIndexInInorder = i;
                break;
            }
        }

        int leftSize = rootIndexInInorder - start;
        // 左边是inorder数组里的start ~ rootIndexInInorder - 1，左边的root是preorder里的rootIndexInPreorder+1的那个
        // 右边是inorder数组里的rootIndexInInorder + 1 ~ end，右边的的root是preorder里的rootIndexInPreorder+leftSize+1的那个
        root.left = build(preorder, rootIndexInPreorder + 1, inorder, start, rootIndexInInorder - 1);
        root.right = build(preorder, rootIndexInPreorder + leftSize + 1, inorder, rootIndexInInorder + 1, end);
        return root;
    }
}
```
```java
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        return build(postorder, postorder.length - 1, inorder, 0, inorder.length - 1);
    }

    private TreeNode build(int[] postorder, int rootIndexInPostOrder, int[] inorder, int start, int end) {
        if (start > end) {
            return null;
        }

        int rootVal = postorder[rootIndexInPostOrder];
        TreeNode root = new TreeNode(rootVal);

        int rootIndexInInorder = -1;
        for (int i = end; i >= start; i--) {
            if (inorder[i] == rootVal) {
                rootIndexInInorder = i;
                break;
            }
        }

        int rightSize = end - rootIndexInInorder;
        root.right = build(postorder, rootIndexInPostOrder - 1, inorder, rootIndexInInorder + 1, end);
        root.left = build(postorder, rootIndexInPostOrder - rightSize - 1, inorder, start, rootIndexInInorder - 1);
        return root;
    }
}
```
包括[有序数组构造为BST](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)（分治）：
```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return build(nums, 0, nums.length - 1);
    }

    private TreeNode build(int[] nums, int start, int end) {
        if (start > end) {
            return null;
        }

        int mid = (start + end) / 2;
        TreeNode root = new TreeNode(nums[mid]);

        root.left = build(nums, start, mid - 1);
        root.right = build(nums, mid + 1, end);
        return root;
    }
}
```
最好是左闭右开：
```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        // 左闭右开
        return divide(nums, 0, nums.length);
    }

    private TreeNode divide(int[] nums, int left, int right) {
        if (left >= right) {
            return null;
        }

        int mid = left + (right - left) / 2;
        TreeNode root = new TreeNode(nums[mid]);
        // 左闭右开
        root.left = divide(nums, left, mid);
        // 左闭右开
        root.right = divide(nums, mid + 1, right);
        return root;
    }
}
```

和麻烦点儿的[有序链表构造为BST](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/)：
```java
class Solution {
    public TreeNode sortedListToBST(ListNode head) {
        return divide(head, null);
    }

    private TreeNode divide(ListNode head, ListNode end) {
        // 这个算防止一开始为null吧
        if (head == null) {
            return null;
        }

        // 退出条件
        if (head == end) {
            return null;
        }

        ListNode mid = findMid(head, end);

        TreeNode root = new TreeNode(mid.val);
        root.left = divide(head, mid);
        // 这个必须是mid+1，因为mid已经用过了
        root.right = divide(mid.next, end);
        return root;
    }

    private ListNode findMid(ListNode head, ListNode end) {
        ListNode fast = head, slow = head;

        while (fast != end && fast.next != end) {
            slow = slow.next;
            fast = fast.next.next;
        }

        return slow;
    }
}
```
官方的题解也不错，很精髓：
```java
class Solution {
    public TreeNode sortedListToBST(ListNode head) {
        return buildTree(head, null);
    }

    public TreeNode buildTree(ListNode left, ListNode right) {
        if (left == right) {
            return null;
        }
        ListNode mid = getMedian(left, right);
        TreeNode root = new TreeNode(mid.val);
        root.left = buildTree(left, mid);
        root.right = buildTree(mid.next, right);
        return root;
    }

    public ListNode getMedian(ListNode left, ListNode right) {
        ListNode fast = left;
        ListNode slow = left;
        while (fast != right && fast.next != right) {
            fast = fast.next;
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
}
```

同样是有序数组，[95. 不同的二叉搜索树 II](https://leetcode.cn/problems/unique-binary-search-trees-ii/description/)没要求平衡，所以就可以以任意节点作为root。它的思维比上面又多套了一层，**核心是以当前每一个点作为root**：
- **数组分两段，当前pivot是root，左边是左子树，右边是右子树**；
- **最后两边的合法子树全排列一下就行了……**

只能说想不来，照葫芦画瓢吧：
```java
class Solution {
    public List<TreeNode> generateTrees(int n) {
        return build(1, n + 1);
    }

    private List<TreeNode> build(int start, int end) {
        if (start >= end) {
            // 这个null是必须的，比如左子树为null可以和每一种右子树组成一棵树
            // 但是如果没这个null，下面的双重遍历就没了
            List<TreeNode> result = new ArrayList<>();
            result.add(null);
            return result;
            // 会NPE，所以只能用上面的写法
            // return List.of(null);
        }

        List<TreeNode> result = new ArrayList<>();

        // 以这一棵子树（这一段）的任意一个数字i作为root，排列组合一下
        for (int i = start; i < end; i++) {

            List<TreeNode> lefts = build(start, i);
            List<TreeNode> rights = build(i + 1, end);

            for (TreeNode l : lefts) {
                for (TreeNode r : rights) {
                    TreeNode root = new TreeNode(i);
                    root.left = l;
                    root.right = r;
                    result.add(root);
                }
            }
        }

        return result;
    }
}
```
**注意这个return null，null是一棵子树**。

[894. 所有可能的真二叉树](https://leetcode.cn/problems/all-possible-full-binary-trees/description/)和这个思想类似，不过更简单一些，因为任何一边都不可能为null，必须是奇数个节点。其他部分都一样：
```java
class Solution {
    public List<TreeNode> allPossibleFBT(int n) {
        return build(n);
    }

    private List<TreeNode> build(int cur) {
        if (cur == 1) {
            return List.of(new TreeNode(0));
        }

        List<TreeNode> result = new ArrayList<>();
        
        // 当前要消耗掉一个节点，剩下cur-1个
        cur--;
        for (int i = 1; i < cur; i += 2) {
            List<TreeNode> lefts = build(i);
            List<TreeNode> rights = build(cur - i);

            for (TreeNode l : lefts) {
                for (TreeNode r :rights) {
                    TreeNode root = new TreeNode(0);
                    root.left = l;
                    root.right = r;
                    result.add(root);
                }
            }
        }
        return result;
    }
}
```

> 还真想出来了:D

[241. 为运算表达式设计优先级](https://leetcode.cn/problems/different-ways-to-add-parentheses/description/)，一模一样的思路，**这里可以把符号看作root，组成一棵树，就和上面的两道题一模一样了**：
```java
class Solution {
    public List<Integer> diffWaysToCompute(String expression) {
        return build(expression);
    }

    private List<Integer> build(String exp) {
        int expNumber = number(exp);
        if (expNumber != -1) {
            // 当前子树是一个纯数字
            return List.of(expNumber);
        }

        List<Integer> result = new ArrayList<>();

        for (int i = 0; i < exp.length(); i++) {
            char c = exp.charAt(i);

            // 以每一个符号作为二叉树的root，分别求左右分支
            if (c == '+' || c == '-' || c == '*') {
                List<Integer> lefts = build(exp.substring(0, i));
                List<Integer> rights = build(exp.substring(i + 1, exp.length()));

                for (int l : lefts) {
                    for (int r :rights) {
                        int ans = c == '+' ? l + r :
                                    c == '-' ? l - r : l * r;
                        result.add(ans);
                    }
                }
            }
        }

        return result;
    }

    private int number(String exp) {
        int sum = 0;
        for (char c : exp.toCharArray()) {
            if (!Character.isDigit(c)) {
                return -1;
            }
            sum = sum * 10 + (c - '0');
        }

        return sum;
    }
}
```

最后还想提一下[96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/description/)，它和[95. 不同的二叉搜索树 II](https://leetcode.cn/problems/unique-binary-search-trees-ii/description/)的**区别在于后者需要列出所有的情况，前者却只需要一个数字（有多少种情况）。而且这道题给出的n明显比后者大一些，说明再用这种组合分治的思想会超时。仔细想想，不同的情况下其实里面有很多重复子问题，有重复构建子树的情况，所以这道题需要用动态规划**。

“需要用”的意思是可以不用，可以不用的意思是得会上面的分治。也就是说，**无论如何，得先学会上面这个分治的思路。在此基础上，因为分治有重复子问题，且这道题要的只是一个数字，所以可以用动态规划来解决**。

然后就会发现，经常说动态规划的重点是转移方程，**但转移方程只是使用动态规划后的一个捷径计算，重点是脑子里要有问题本身的解决思路，知道哪一种情况是由哪几种情况组合出来的，这是问题的本质解决思路。在此基础上，如果用了动态规划，这个思路就是转移方程**。

```java
class Solution {
    public int numTrees(int n) {

        int[] dp = new int[n + 1];

        // init
        dp[0] = 1;  // 空子树也是一种情况
        dp[1] = 1;
        // dp[2] = 2;

        // transfer
        // 枚举每一种n对应的结果
        for (int i = 2; i <= n; i++) {
            // 当前root用一个，所以还剩i-1个
            int nodes = i - 1;

            int sum = 0;
            // left最少用0个节点，最多可以占用所有的nodes
            for (int left = 0; left <= nodes; left++) {
                int right = nodes - left;
                sum += dp[left] * dp[right];
            }
            dp[i] = sum;
        }

        return dp[n];
    }
}
```
所以说，**动态规划的题目是和问题本身的解决思路高度相关的。在原有思路的基础上，才是考虑怎么把它转成动态规划的形式，也就是怎么复用记忆图来省去没必要的计算。**

## 路径问题
所用到的方法还是之前总结的通用dfs模板。但是需要注意，虽然倒是dfs，但是对于树来说有前序遍历、后续遍历，不同的处理方式适合不同的题型。**前序遍历适合自顶向下，因为它先处理root。逻辑上从上到下的题目都是前序遍历**。比如[路径总和 II](https://leetcode.cn/problems/path-sum-ii/)、[二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)。

**但是有时候从下到上更符合逻辑，这个时候就需要自底向上，对应的方法是使用后序遍历，因为后序遍历先处理左右节点，最后处理根节点**。比如[判断平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)，它要求从下往上，每一个子树的高度差都不超过1。

### 自顶向下
自顶向下可以从根节点开始，比如：
- [二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/description/)
- 上面说过的[路径总和](https://leetcode.cn/problems/path-sum-ii/description/)

有些看着像是从下往上，但实际上还是从上往下。比如：
- [从叶结点开始的最小字符串](https://leetcode.cn/problems/smallest-string-starting-from-leaf/description/)

也不过是自root向leaf，然后反过来排个序罢了：
```java
class Solution {
    public String smallestFromLeaf(TreeNode root) {
        PriorityQueue<String> pq = new PriorityQueue<>();
        dfs(pq, "", root);
        return pq.size() == 0 ? "" : pq.poll();
    }

    private void dfs(PriorityQueue<String> result, String cur, TreeNode root) {
        if (root == null) {
            return;
        }
        // cur.append((char) (root.val + 'a'));
        cur += (char)(root.val + 'a');
        if (root.left == null && root.right == null) {
            result.offer(new StringBuilder(cur).reverse().toString());
            // 精简一下，反正只要第一个，试试速度
            if (result.size() > 1) {
                String first = result.poll();
                result.clear();
                result.offer(first);
            }
        } else {
            dfs(result, cur, root.left);
            dfs(result, cur, root.right);
        }
        // 不用回退，因为String是传值，不是传引用
        // cur.deleteCharAt(cur.length() - 1);
    }
}
```

自顶向下也可以不从根节点开始，关键点就是：
- 不从根节点开始：意味着**多加一层递归，把每个节点都当做root来一次**；
- 如果也不到叶节点结束：意味着当找到合适的路径之后，**不要return（相当于不剪枝），继续递归下去**；

比如：
- [路径总和 III](https://leetcode.cn/problems/path-sum-iii/description/)

```java
class Solution {
    public int pathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return 0;
        }
        int ret = 0;
        ret += sum(root, targetSum);
        ret += pathSum(root.left, targetSum);
        ret += pathSum(root.right, targetSum);
        return ret;
    }

    // 没有像之前一样传个sum，因为直接拿target - node.value了
    private int sum(TreeNode root, long targetSum) {
        int ret = 0;
        if (root == null) {
            return 0;
        }

        if (root.val == targetSum) {
            // result.add(new ArrayList<>(cur));
            ret++;
        }
        // 不管是否满足条件，都要继续递归下去
        ret += sum(root.left, targetSum - root.val);
        ret += sum(root.right, targetSum - root.val);

        return ret;
    }
}
```

如果要所有的情况，则使用list承接，使用cur list做加、减，以回溯：
```java
class Solution {
    public int pathSum(TreeNode root, int targetSum) {
        List<List<Integer>> result = new ArrayList<>();
        dfs(result, root, targetSum);
        return result.size();
    }

    private void dfs(List<List<Integer>> result, TreeNode root, int targetSum) {
        if (root == null) {
            return;
        }
        sum(result, new ArrayList<>(), root, 0, targetSum);
        dfs(result, root.left, targetSum);
        dfs(result, root.right, targetSum);
    }

    private void sum(List<List<Integer>> result, List<Integer> cur, TreeNode root, int sum, int target) {
        if (root == null) {
            return;
        }
        sum += root.val;
        cur.add(root.val);
        if (sum == target) {
            result.add(new ArrayList<>(cur));
        }
        // 不管是否满足条件，都要继续递归下去
        sum(result, cur, root.left, sum, target);
        sum(result, cur, root.right, sum, target);
        cur.remove(cur.size() - 1);
    }
}
```

最后再说个例子——经常面别人的树的覆盖，这里有一个类似的题[另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/description/)，其实也是不从根节点开始。不过这个不是树的覆盖，所以这个比较到leaf了。

> 在LeetCode上竟然是简单题……

### 自底向上：O(n)
**上面已经介绍过了，逻辑上从下往上的情况应该用自底向上的算法，那就是后序遍历**！比如[判断平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)：

**如果用自顶向下，就会比较重复**，比如判断第一层的高度，要遍历整个二叉树，判断第二层的时候，要再遍历一遍。所以整个算法是O(n)*O(n)。
```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        if (root == null) {
            return true;
        }
        return (Math.abs(depth(root.left) - depth(root.right)) <= 1) && isBalanced(root.left) && isBalanced(root.right);
    }

    private int depth(TreeNode root) {
        if (root == null) {
            return 0;
        }

        return 1 + Math.max(depth(root.left), depth(root.right));
    }
}
```

先来看一个不成功的自底向上。第一个方法是后序遍历，所以是自底向上；第二个方法依然是前序，所以是自顶向下：
```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        if (root == null) {
            return true;
        }
        // 最后判断本层，所以是自下而上判断
        return isBalanced(root.left) && isBalanced(root.right) && (Math.abs(depth(root.left) - depth(root.right)) <= 1);
    }

    private int depth(TreeNode root) {
        if (root == null) {
            return 0;
        }

        return 1 + Math.max(depth(root.left), depth(root.right));
    }
}
```
这个算法中，`isBalanced`采用了后序遍历，先判断底层是不是平衡二叉树，最后判断本层。但是没什么卵用，因为非平衡二叉树不一定是从哪儿开始不平衡的，可能是上面也可能是下面，所以从哪儿开始判断并没有太大区别。本质上，它每次还是重新计算了每一个子树的高度。

**所以真正的自底向上应该是自底向上算高度，同时判断是否符合平衡二叉树要求**。这样最终只对每个值算了一次高度，**而且用上了之前子节点的高度信息**，一遍就搞定了，算法为O(n)：
```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return depth(root) != -1;
    }

    private int depth(TreeNode root) {
        if (root == null) {
            return 0;
        }

        // 先算左右，再处理root，所以是自底向上
        int l = depth(root.left), r = depth(root.right);
        
        // 为了能在计算高度的同时返回是否为平衡二叉树（true/false），选择用是否为-1来代表true/false，因此返回int就行了
        if (l == -1 || r == -1 || Math.abs(l - r) > 1) {
            return -1;
        }

        return 1 + Math.max(l, r);
    }
}
```

#### 自底向上模板

> 求树的高度，本身就是自底向上。求树的深度，应该用自顶向下。但是root节点的高度和深度是一样的，所以一般也写成自底向上。https://cloud.tencent.com/developer/article/1859061

自顶向下求树的高度
```java
class Solution {
public:
    int result;
    void getDepth(TreeNode* node, int depth) {
        result = depth > result ? depth : result; // 中
        if (node->left == NULL && node->right == NULL) return ;
        if (node->left) { // 左
            getDepth(node->left, depth + 1);
        }
        if (node->right) { // 右
            getDepth(node->right, depth + 1);
        }
        return ;
    }
    int maxDepth(TreeNode* root) {
        result = 0;
        if (root == 0) return result;
        getDepth(root, 1);
        return result;
    }
};
```

分割线-------------

这种自底向上题的**套路**都是：
1. **后序遍历**；
2. 按照题意找到**本节点（未必是全局）的“高度”，这个高度未必是物理上的树高，而是满足题意的一种metric。因为上层节点只能用它的root连接本子树的高度**；
3. **方法返回的是当前节点的“高度”**；
3. **同时更新max**：本节点使用root连接两颗子树的“高度”，得到题目中规定的max。然后找个全局max更新一下所有节点中最大的那个max即可。

如果用套路重写上面的代码：
```java
class Solution {
    // 全局的“max”
    boolean balance = true;
    public boolean isBalanced(TreeNode root) {
        depth(root);
        return balance;
    }

    private int depth(TreeNode root) {
        if (root == null) {
            return 0;
        }

        // 先算左右，再处理root，所以是自底向上
        int l = depth(root.left), r = depth(root.right);
        
        if (Math.abs(l - r) > 1) {
            balance = false;
        }

        // 本节点想判断是否平衡，就是需要求本节点的高度
        return 1 + Math.max(l, r);
    }
}
```

[二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)，一模一样的问题！**如果是自顶向下，O(n^2)**：
```java
class Solution {
    public int diameterOfBinaryTree(TreeNode root) {
        if (root == null) {
            return 0;
        }
        // 过root的路径数、左子树的最大直径、右子树的最大直径
        return Math.max(height(root.left) + height(root.right), Math.max(diameterOfBinaryTree(root.left), diameterOfBinaryTree(root.right)));
    }

    private int height(TreeNode root) {
        if (root == null) {
            return 0;
        }

        return 1 + Math.max(height(root.left), height(root.right));
    }
}
```

**自底向上，O(n)**：
```java
class Solution {

    int max = -1;

    public int diameterOfBinaryTree(TreeNode root) {
        if (root == null) {
            return 0;
        }
        height(root);
        return max;
    }

    private int height(TreeNode root) {
        if (root == null) {
            return 0;
        }

        int l = height(root.left);
        int r = height(root.right);
        // 求高度的同时，记录下最大值。这次height函数不能返回两个值了，只能用全局变量了……符合上述“模板套路”
        // 思想是一致的，自底向上——后序遍历
        max = Math.max(max, l + r);
        
        // 本节点的max，就是最高的左右子树之和
        return 1 + Math.max(l, r);
    }
}
```

[最长同值路径](https://leetcode.cn/problems/longest-univalue-path/)，这个子树的高度就是左右子树和root同值的情况下的子树高度的最大值：
```java
class Solution {
    // 路径，最小也就是0了
    int max = 0;

    public int longestUnivaluePath(TreeNode root) {
        height(root);
        return max;
    }

    private int height(TreeNode root) {
        if (root == null) {
            return 0;
        }

        int l = height(root.left);
        int r = height(root.right);

        // 算的是路径长度
        int cur = 0;
        if (sameValue(root.left, root)) {
            cur += l;
        }
        if (sameValue(root.right, root)) {
            cur += r;
        }
        max = Math.max(max, cur);

        // 返回的是每个点能积累的当前路径长度
        return 1 + Math.max((sameValue(root.left, root) ? l : 0), (sameValue(root.right, root) ? r : 0));
    }

    private boolean sameValue(TreeNode a, TreeNode b) {
        if (a == null) {
            return b == null;
        }

        if (b == null) {
            return a == null;
        }

        return a.val == b.val;
    }
}
```
稍微合并一下，就是我们看到的模板代码：
```java
class Solution {
    // 路径，最小也就是0了
    int max = 0;

    public int longestUnivaluePath(TreeNode root) {
        height(root);
        return max;
    }

    private int height(TreeNode root) {
        if (root == null) {
            return 0;
        }

        int l = height(root.left);
        int r = height(root.right);

        int adjustL = sameValue(root.left, root) ? l : 0;
        int adjustR = sameValue(root.right, root) ? r : 0;

        // 算的是路径长度
        max = Math.max(max, adjustL + adjustR);

        // 返回的是每个点能积累的当前路径长度
        return 1 + Math.max(adjustL, adjustR);
    }

    private boolean sameValue(TreeNode a, TreeNode b) {
        if (a == null) {
            return b == null;
        }

        if (b == null) {
            return a == null;
        }

        return a.val == b.val;
    }
}
```
[二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)。这个子树的“高度”更虚幻一些，不是左右子树的物理高度，而是叠加值高度。需要注意的点是，**端点不需要必须是叶子。所以这里处理的时候需要注意一下，如果子子树积累过来的值是负的，我们不加上它就行了，也就是设为0**：
```java
class Solution {
    int max = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        if (root == null) {
            return 0;
        }
        sum(root);
        return max;
    }

    private int sum(TreeNode root) {
        if (root == null) {
            return 0;
        }

        int l = sum(root.left);
        int r = sum(root.right);

        // 如果左右子树贡献的是负的，就不加上了
        int adjustL = Math.max(l, 0);
        int adjustR = Math.max(r, 0);

        // 最终求的是最大路径和
        max = Math.max(max, root.val + adjustL + adjustR);

        // 但是dfs返回的是当前子树的最大“高度”
        return root.val + Math.max(adjustL, adjustR);
    }
}
```

## 只是为了遍历一遍
对于那些只是为了遍历一遍,或者对于那些要求返回的信息比较多的题，比如[二叉树的堂兄弟节点](https://leetcode.cn/problems/cousins-in-binary-tree/description/)，如果用dfs，返回的信息不够。这个时候如果用dfs，**那么dfs就是为了遍历一遍而已，所以可以用任何序（自顶向下自底向上都无所谓的），不用返回任何信息，而是用全局变量记录x和y的深度和父节点**。
```java
class Solution {
    public boolean isCousins(TreeNode root, int x, int y) {
        // root没有父节点id，瞎传一个
        dfs(root, x, y, 0, -2);
        return depthX == depthY && parentX != parentY;
    }

    int depthX = -1, depthY = -1, parentX = -1, parentY = -1;

    private void dfs(TreeNode root, int x, int y, int depth, int parentId) {
        if (root == null) {
            return;
        }

        if (root.val == x) {
            depthX = depth;
            parentX = parentId;
        }

        if (root.val == y) {
            depthY = depth;
            parentY = parentId;
        }

        dfs(root.left, x, y, depth + 1, root.val);
        dfs(root.right, x, y, depth + 1, root.val);
    }
}
```

再回头看一下[二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/)，dfs除了跑一遍，还要算子树路径和，所以是自底向上，dfs跑的时候得用后序遍历，但是它也是返回的信息不够，所以用全局变量记录。

# DFS总结
- 终结条件
- 情况选择
- 剪枝
- 参数列表
- 返回值（返回方式）

**通用dfs基本都是前序。如果是树，dfs的时候考虑一下要不要用后序（从下往上思考问题）。**

